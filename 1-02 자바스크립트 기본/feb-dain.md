# 2-4. 변수와 상수

'상수’는 변수의 값이 절대 변하지 않음을 의미합니다. 그중에는 (빨간색을 나타내는 16진수 값처럼) 코드가 실행되기 전에 이미 그 값을 알고 있는 상수도 있고, 런타임 과정에서 *계산되지만* 최초 할당 이후 값이 변하지 않는 상수도 있습니다.

예시:

```jsx
const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */;
```

`pageLoadTime`의 값은 페이지가 로드되기 전에는 정해지지 않기 때문에 일반적인 방식으로 변수명을 지었습니다. 하지만 이 값은 최초 할당 이후에 변경되지 않으므로 여전히 상수입니다.

정리하자면, 대문자 상수는 ‘하드 코딩한’ 값의 별칭을 만들 때 사용하면 됩니다.

## [바람직한 변수명](https://ko.javascript.info/variables#ref-1350) ✨🔥

변수에 관한 매우 중요한 사실이 한 가지 더 있습니다.

변수명은 간결하고, 명확해야 합니다. 변수가 담고있는 것이 무엇인지 잘 설명할 수 있어야 하죠.

변수의 이름을 짓는 것은 프로그래밍에서 가장 중요하고 복잡한 기술 중 하나입니다. 변수명만 슬쩍 봐도 초보자가 코드를 작성했는지, 노련한 개발자가 작성했는지 알 수 있습니다.

- `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용하세요.
- 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 `a`, `b`, `c`와 같은 짧은 이름은 피하세요.
- 최대한 서술적이고 간결하게 명명해 주세요. `data`와 `value`는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합시다.
- 자신만의 규칙이나 소속된 팀의 규칙을 따르세요. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 `currentVisitor`나 `newManInTown`이 아닌 `currentUser`나 `newUser`라는 이름으로 지어야 합니다.

**재사용 아니면 새로 만들기?**

개발자 중에는 새로운 변수를 선언하기보다 기존 변수를 재사용 하는 걸 선호하는 게으른 분들이 있습니다.

재사용된 변수는 과거에 붙여진 스티커를 떼지 않은 채 물건만 바뀐 상자와 같습니다. 상자 안에는 무엇이 들어 있을까요? 내용물에 대한 정보를 알고 있는 사람은 누구인가요? 이를 알기 위해선 상자에 가까이 다가가 확인해야만 합니다.

변수를 재사용하면 변수 선언에 쏟는 노력을 좀 덜 순 있겠지만, 디버깅에 열 배 더 많은 시간을 쏟아야 합니다.

변수를 추가하는 것은 악습이 아닙니다. 좋은 습관입니다.

모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘해줍니다. 변수를 추가한다고 해서 성능 이슈가 생기지 않죠. 값이 다른 경우, 변수를 다르게 선언해 주면 코드 최적화에 도움이 될 수도 있습니다.

<br>
<br>

# 2-5. 자료형

## [BigInt](https://ko.javascript.info/types#ref-1509)

내부 표현 방식 때문에 자바스크립트에선 `(253-1)`(`9007199254740991`) 보다 큰 값 혹은 `-(253-1)` 보다 작은 정수는 '숫자형’을 사용해 나타낼 수 없습니다.

사실 대부분의 상황에서 이런 제약사항은 문제가 되지 않습니다. 그렇지만 암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때는 이런 큰 숫자가 필요합니다.

`BigInt`형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있습니다.

`BigInt`형 값은 정수 리터럴 끝에 `n`을 붙이면 만들 수 있습니다.

```jsx
// 끝에 'n'이 붙으면 BigInt형 자료입니다.
const bigInt = 1234567890123456789012345678901234567890n;
```

`BigInt`형 숫자는 자주 쓰이지 않기 때문에 여기서 자세히 다루지 않고 별도의 챕터, [BigInt](https://ko.javascript.info/bigint)에서 설명드리겠습니다. 아주 큰 숫자를 사용해야 하는 경우라면 해당 챕터를 참고해 주시기 바랍니다.

**호환성 이슈**

이 글이 작성된 시점엔 Firefox, Chrome, Edge, Safari에서만 `BigInt`를 지원합니다. IE에선 지원하지 않습니다.

## [객체와 심볼](https://ko.javascript.info/types#ref-1514)

`객체(object)`형은 특수한 자료형입니다.

객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부릅니다. 반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있습니다.

이런 특징 때문에 자바스크립트에서 객체는 좀 더 특별한 취급을 받습니다. 자세한 내용은 원시형을 배우고 난 후 [객체](https://ko.javascript.info/object)에서 다루도록 하겠습니다.

`심볼(symbol)`형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용됩니다. 심볼형에 대해선 객체를 학습하고 난 이후에 자세히 알아보겠습니다.

## [typeof 연산자](https://ko.javascript.info/types#type-typeof)

`typeof` 연산자는 인수의 자료형을 반환합니다. 자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용합니다.

`typeof` 연산자는 두 가지 형태의 문법을 지원합니다.

1. 연산자: `typeof x`
2. 함수: `typeof(x)`

괄호가 있든 없든 결과가 동일합니다.

`typeof x`를 호출하면 인수의 자료형을 나타내는 문자열을 반환합니다.

```jsx
typeof undefined; // "undefined"

typeof 0; // "number"

typeof 10n; // "bigint"

typeof true; // "boolean"

typeof "foo"; // "string"

typeof Symbol("id"); // "symbol"

typeof Math // "object"  (1)
`typeof null // "object"  (2)``typeof alert // "function"  (3)`;
```

마지막 세 줄은 약간의 설명이 필요해 보이네요.

1. `Math`는 수학 연산을 제공하는 내장 객체이므로 `"object"`가 출력됩니다. `Math`에 대해선 [숫자형](https://ko.javascript.info/number) 챕터에서 학습하도록 하겠습니다. 내장 객체는 객체형이라는 것을 알려주기 위해 이런 예시를 작성해 보았습니다.
2. `typeof null`의 결과는 `"object"`입니다. `null`은 별도의 고유한 자료형을 가지는 특수 값으로 객체가 아니지만, 하위 호환성을 유지하기 위해 이런 오류를 수정하지 않고 남겨둔 상황입니다. 언어 자체의 오류이므로 `null`이 객체가 아님에 유의하시기 바랍니다.
3. `typeof`는 피연산자가 함수면 `"function"`을 반환합니다. 그러므로 `typeof alert`는 `"function"`을 출력해줍니다. 그런데 '함수’형은 따로 없습니다. 함수는 객체형에 속합니다. 이런 동작 방식이 형식적으론 잘못되긴 했지만, 아주 오래전에 만들어진 규칙이었기 때문에 하위 호환성 유지를 위해 남겨진 상태입니다. 한편, 실무에선 이런 특징이 매우 유용하게 사용되기도 합니다.

자바스크립트에는 여덟 가지 기본 자료형이 있습니다.

- `숫자형` – 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용합니다. 정수의 한계는 ±2 입니다.
- `bigint` – 길이 제약 없이 정수를 나타낼 수 있습니다.
- `문자형` – 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용합니다. 단일 문자를 나타내는 별도의 자료형은 없습니다.
- `불린형` – `true`, `false`를 나타낼 때 사용합니다.
- `null` – `null` 값만을 위한 독립 자료형입니다. `null`은 알 수 없는 값을 나타냅니다.
- `undefined` – `undefined` 값만을 위한 독립 자료형입니다. `undefined`는 할당되지 않은 값을 나타냅니다.
- `객체형` – 복잡한 데이터 구조를 표현할 때 사용합니다.
- `심볼형` – 객체의 고유 식별자를 만들 때 사용합니다.

`typeof` 연산자는 피연산자의 자료형을 알려줍니다.

- `typeof x` 또는 `typeof(x)` 형태로 사용합니다.
- 피연산자의 자료형을 문자열 형태로 반환합니다.
- `null`의 typeof 연산은 `"object"`인데, 이는 언어상 오류입니다. null은 객체가 아닙니다.

<br>
<br>

# 2-6. alert, prompt, confirm을 이용한 상호작용

메시지가 있는 작은 창은 *모달 창(modal window)*
 이라고 부릅니다. '모달’이란 단어엔 페이지의 나머지 부분과 상호 작용이 불가능하다는 의미가 내포되어 있습니다. 따라서 사용자는 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수 없습니다. 확인 버튼을 누르기 전까지 말이죠.

## [prompt](https://ko.javascript.info/alert-prompt-confirm#ref-1614)

브라우저에서 제공하는 `prompt` 함수는 두 개의 인수를 받습니다.

`result = prompt(title, [default]);`

함수가 실행되면 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워줍니다.

`title`사용자에게 보여줄 문자열`default`입력 필드의 초깃값(선택값)

**인수를 감싸는 대괄호 `[...]`의 의미**

`default`를 감싸는 대괄호는 이 매개변수가 필수가 아닌 선택값이라는 것을 의미합니다.

사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있습니다. 값을 입력하길 원하지 않는 경우는 취소(Cancel) 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나가면 됩니다.

`prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환합니다. 사용자가 입력을 취소한 경우는 `null`이 반환됩니다.

**Internet Explorer(IE)에서는 항상 '기본값’을 넣어주세요.**

프롬프트 함수의 두 번째 매개변수는 선택사항이지만, 이 매개변수가 없는 경우 IE는 `"undefined"`를 입력 필드에 명시합니다.

아래 코드를 IE에서 실행해 보세요.

`let test = prompt("Test");`

IE 사용자를 비롯한 모든 사용자에게 깔끔한 프롬프트를 보여주려면 아래와 같이 두 번째 매개변수를 항상 전달해 줄 것을 권장합니다.

`let test = prompt("Test", ''); // <-- IE 사용자를 위한 매개변수 처리`

## [컨펌 대화상자](https://ko.javascript.info/alert-prompt-confirm#ref-1615)

문법:

`result = confirm(question);`

`confirm` 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여줍니다.

사용자가 확인 버튼을 누르면 `true`, 그 외의 경우는 `false`를 반환합니다.

```jsx
let isBoss = confirm("당신이 주인인가요?");

alert(isBoss); // 확인 버튼을 눌렀다면 true가 출력됩니다.
```

<br>
<br>

# 2-7. 형 변환

아래는 숫자형으로 변환 시 적용되는 규칙입니다.

| 전달받은 값    | 형 변환 후                                                                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| undefined      | NaN                                                                                                                                                    |
| null           | 0                                                                                                                                                      |
| true and false | 1 과 0                                                                                                                                                 |
| string         | 문자열의 처음과 끝 공백이 제거됩니다. 공백 제거 후 남아있는 문자열이 없다면 0, 그렇지 않다면 문자열에서 숫자를 읽습니다. 변환에 실패하면 NaN이 됩니다. |

`null`과 `undefined`는 숫자형으로 변환 시 결과가 다르다는 점에 유의하시기 바랍니다.

`null`은 `0`이 되고

`undefined`는 `NaN`이 됩니다.

## [불린형으로 변환](https://ko.javascript.info/type-conversions#ref-1617)

불린형으로의 변환은 아주 간단합니다.

이 형 변환은 논리 연산을 수행할 때 발생합니다(논리 연산에 관한 내용은 뒤 챕터에서 다루고 있습니다). `Boolean(value)`를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있습니다.

불린형으로 변환 시 적용되는 규칙은 다음과 같습니다.

- 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 됩니다.
- 그 외의 값은 `true`로 변환됩니다.

```jsx
alert(Boolean(1)); // 숫자 1(true)
alert(Boolean(0)); // 숫자 0(false)

alert(Boolean("hello")); // 문자열(true)
alert(Boolean("")); // 빈 문자열(false)
```

**주의: 문자열 `"0"`은 `true`입니다.**

PHP 등의 일부 언어에선 문자열 `"0"`을 `false`로 취급합니다. 그러나 자바스크립트에선 비어 있지 않은 문자열은 언제나 `true`입니다.

```jsx
alert(Boolean("0")); // true alert( Boolean(" ") ); // 공백이 있는 문자열도 비어있지 않은 문자열이기 때문에 true로 변환
```

<br>
<br>

# 2-8. 기본 연산자와 수학

## [용어: ‘단항’, ‘이항’, ‘피연산자’](https://ko.javascript.info/operators#ref-1513)

연산자에 대해 학습하기 전에, 앞으로 자주 등장하게 될 용어 몇 가지를 정리해 보겠습니다.

- *피연산자(operand)* 는 연산자가 연산을 수행하는 대상입니다. `5 * 2`에는 왼쪽 피연산자 `5`와 오른쪽 피연산자 `2`, 총 두 개의 피연산자가 있습니다. '피연산자’는 '인수(argument)'라는 용어로 불리기도 합니다.
- 피연산자를 하나만 받는 연산자는 *단항(unary) 연산자* 라고 부릅니다. 피연산자의 부호를 뒤집는 단항 마이너스 연산자 ``는 단항 연산자의 대표적인 예입니다.

  ```jsx
  let x = 1;

  x = -x;
  alert(x); // -1, 단항 마이너스 연산자는 부호를 뒤집습니다.
  ```

- 두 개의 피연산자를 받는 연산자는 *이항(binary) 연산자* 라고 부릅니다. 마이너스 연산자는 아래와 같이 이항 연산자로 쓸 수도 있습니다.
  ```jsx
  let x = 1,
    y = 3;
  alert(y - x); // 2, 이항 마이너스 연산자는 뺄셈을 해줍니다.
  ```
  위와 같이 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자(뺄셈 연산자)는 기호는 같지만 수행하는 연산이 다릅니다. 두 연산을 구분하는 기준은 피연산자의 개수입니다.

## [수학](https://ko.javascript.info/operators#ref-1514)

자바스크립트에서 지원하는 수학 연산자는 다음과 같습니다.

- 덧셈 연산자 `+`,
- 뺄셈 연산자 `-`,
- 곱셈 연산자 `*`,
- 나눗셈 연산자 `/`,
- 나머지 연산자 `%`,
- 거듭제곱 연산자 `**`

## [이항 연산자 '+'와 문자열 연결](https://ko.javascript.info/operators#ref-1517)

이제 학교에서 배운 기본 산술 연산자를 넘어, 자바스크립트가 제공하는 특별한 연산자 기능에 대해 살펴봅시다.

덧셈 연산자 `+`는 대개 숫자를 더한 결과를 반환합니다.

그런데 이항 연산자 `+`의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열을 병합(연결)합니다.

```jsx
let s = "my" + "string";
alert(s); // mystring
```

따라서 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 주의해야 합니다.

```jsx
alert("1" + 2); // "12"
alert(2 + "1"); // "21"
```

첫 번째 피연산자가 문자열인지, 두 번째 피연산자가 문자열인지는 중요하지 않습니다. 피연산자 중 어느 하나가 문자열이면 다른 하나도 문자열로 변환됩니다.

좀 더 복잡한 예시를 살펴봅시다.

```jsx
alert(2 + 2 + "1"); // '221'이 아니라 '41'이 출력됩니다.
```

연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 이런 결과가 나왔습니다. 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어납니다.

이처럼 이항 덧셈 연산자 `+`는 문자열 연결과 변환이라는 특별한 기능을 제공합니다. 다른 산술 연산자가 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것과는 대조적입니다.

아래는 뺄셈 `-`과 나눗셈 `/` 연산자가 어떻게 문자형 피연산자를 다루는지를 보여줍니다.

```jsx
alert(6 - "2"); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
alert("6" / "2"); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.
```

단항 연산자 +와 숫자형으로의 변환
덧셈 연산자 +는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있습니다.

숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않습니다. 그러나 피연산자가 숫자가 아닌 경우엔 숫자형으로의 변환이 일어납니다.

```jsx
// 숫자에는 아무런 영향을 미치지 않습니다.
let x = 1;
alert(+x); // 1
```

```jsx
let y = -2;
alert(+y); // -2
```

```jsx
// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
단항 덧셈 연산자는 짧은 문법으로도 Number(...)와 동일한 일을 할 수 있게 해줍니다.
```

개발을 하다 보면 문자열을 숫자로 변환해야 하는 경우가 자주 생깁니다. HTML 폼(form) 필드에서 값을 가져왔는데 그 값이 문자형일 때 같이 말이죠. 실제로 폼에서 가지고 온 값은 대개 문자열 형태입니다.

이항 덧셈 연산자를 사용하면 아래와 같이 값이 문자열로 변해서 연결될 겁니다.

```jsx
let apples = "2";
let oranges = "3";
```

```jsx
alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.
원하는 대로 값을 더해주려면, 단항 덧셈 연산자를 사용해 피연산자를 숫자형으로 변화시키면 됩니다.
```

```jsx
let apples = "2";
let oranges = "3";
```

```jsx
// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert(+apples + +oranges); // 5
```

```jsx
// Number(...)를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 기네요.
// alert( Number(apples) + Number(oranges) ); // 5
```

## [연산자 우선순위](https://ko.javascript.info/operators#ref-1519)

하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 *우선순위(precedence)* 에 의해 결정됩니다.

`1 + 2 * 2`라는 식이 있을 때 곱셈이 먼저, 그 후에 덧셈이 일어난다는 것을 알고 계실 겁니다. 이런 개념이 연산자 우선순위입니다. 여기서 곱셈은 덧셈보다 *더 높은 우선순위*를 가지죠.

자바스크립트에서 정의한 연산자 우선순위가 마음에 들지 않는다면, 괄호를 사용하면 됩니다. 괄호는 모든 연산자보다 우선순위가 높기 때문에 자바스크립트에서 정의한 연산자 우선순위를 무력화시킵니다. 표현식 `(1 + 2) * 2`에서 괄호로 둘러싼 덧셈 연산자가 먼저 수행되는 것 같이 말이죠.

자바스크립트는 다양한 연산자를 제공하는데, 이 모든 연산자엔 우선순위가 매겨져 있습니다. 우선순위 숫자가 클수록 먼저 실행됩니다. 순위가 같으면 왼쪽부터 시작해서 오른쪽으로 연산이 수행됩니다.

아래는 [우선순위 테이블(precedence table)](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence)의 일부를 발췌한 표입니다. 순서를 기억할 필요는 없지만, 동일한 기호의 단항 연산자는 이항 연산자보다 우선순위가 더 높다는 것에 주목해 주시기 바랍니다.

| 순위 | 연산자 이름 | 기호 |
| ---- | ----------- | ---- |
| …    | …           | …    |
| 17   | 단항 덧셈   | +    |
| 17   | 단항 부정   | -    |
| 16   | 지수        | \*\* |
| 15   | 곱셈        | \*   |
| 15   | 나눗셈      | /    |
| 13   | 덧셈        | +    |
| 13   | 뺄셈        | -    |
| …    | …           | …    |
| 3    | 할당        | =    |
| …    | …           | …    |

'단항 덧셈 연산자’는 우선순위 `17`로, '(이항) 덧셈 연산자’의 우선순위 `13`보다 높습니다. 표현식 `"+apples + +oranges"`에서 단항 덧셈 연산자가 덧셈보다 먼저 수행되는 이유가 바로 이 때문입니다.

## [할당 연산자 체이닝](https://ko.javascript.info/operators#ref-1522)

할당 연산자는 아래와 같이 여러 개를 연결할 수도 있습니다(체이닝).

```jsx
let a, b, c;

a = b = c = 2 + 2;

alert(a); // 4
alert(b); // 4
alert(c); // 4
```

이렇게 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행됩니다. 먼저 가장 우측의 `2 + 2`가 평가되고, 그 결과가 좌측의 `c`, `b`, `a`에 순차적으로 할당됩니다. 모든 변수가 단일 값을 공유하게 되죠.

그런데 되도록이면 연산자를 체이닝 하는것 보다 가독성을 위해 아래와 같이 줄을 나눠 코드를 작성하길 권유드립니다.

`c = 2 + 2; b = c; a = c;`

이렇게 작성하면 읽기도 쉽고, 눈을 빠르게 움직이며 코드를 읽을 수 있습니다.

## **복합 할당 연산자**

프로그램을 짜다 보면, 변수에 연산자를 적용하고 그 결과를 같은 변수에 저장해야 하는 경우가 종종 생깁니다.

아래와 같이 말이죠.

`let n = 2; n = n + 5; n = n * 2;`

이때, `+=`와 `*=`연산자를 사용하면 짧은 문법으로 동일한 연산을 수행할 수 있습니다.

```jsx
let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n _= 2; // n은 14가 됩니다(n = n _ 2와 동일).

alert( n ); // 14
```

이런 ‘복합 할당’ 연산자는 산술 연산자와 비트 연산자에도 적용할 수 있습니다. `/=`, `-=` 등의 연산자를 만들 수 있죠.

복합 할당 연산자의 우선순위는 할당 연산자와 동일합니다. 따라서 대부분 다른 연산자가 실행된 후에 복합 할당 연산자가 실행됩니다.

```jsx
let n = 2;

n \*= 3 + 5;

alert( n ); // 16 (_=의 우측이 먼저 평가되므로, 위 식은 n _= 8과 동일합니다.)
```

## **[증가·감소 연산자](https://ko.javascript.info/operators#ref-1524)**

**중요:**

증가·감소 연산자는 변수에만 쓸 수 있습니다. `5++`와 같이 값에 사용하려고 하면 에러가 발생합니다.

`++`와`--` 연산자는 변수 앞이나 뒤에 올 수 있습니다.

- `counter++`와 같이 피연산자 뒤에 올 때는, '후위형(postfix form)'이라고 부릅니다.
- `++counter`와 같이 피연산자 앞에 올 때는, '전위형(prefix form)'이라고 부릅니다.

후위형과 전위형은 피연산자인 `counter`를 `1`만큼 증가시켜 준다는 점에서 동일한 일을 합니다.

두 형의 차이는 `++/--`의 반환 값을 사용할 때 드러납니다.

자, 다시 상기해 보도록 합시다. 이미 배운 바와 같이 모든 연산자는 값을 반환합니다. 증가·감소 연산자도 마찬가지입니다. 전위형은 증가·감소 후의 새로운 값을 반환하는 반면, 후위형은 증가·감소 전의 기존 값을 반환합니다.

아래 예시를 통해 차이점을 직접 살펴보도록 합시다.

```jsx
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

`(*)`로 표시한 줄의 *전위형* `++counter`는 `counter`를 증가시키고 새로운 값 `2`를 반환합니다. 따라서 `alert`는 `2`를 표시합니다.

이제 후위형을 살펴봅시다.

```jsx
let counter = 1;
let a = counter++; // (*) ++counter를 counter++로 바꿈

alert(a); // 1
```

`(*)`로 표시한 줄의 *후위형* `counter++`는 `counter`를 증가시키긴 하지만, 증가 전의 *기존* 값을 반환합니다. 따라서 `alert`는 `1`을 표시합니다.

증가, 감소 연산자에 대한 내용을 정리하면 아래와 같습니다.

- 반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없습니다.

  ```jsx
  let counter = 0;
  counter++;
  ++counter;
  alert(counter); // 2, 위 두 라인은 동일한 연산을 수행합니다.
  ```

- 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 됩니다.

  ```jsx
  let counter = 0;
  alert(++counter); // 1
  ```

- 값을 증가시키지만, 증가 전의 기존값을 사용하려면 후위형 증가 연산자를 사용하면 됩니다.
  ```jsx
  let counter = 0;
  alert(counter++); // 0
  ```

**다른 연산자 사이의 증가·감소 연산자**

`++/--` 연산자를 표현식 중간에 사용하는 것도 가능합니다. 이때, 증가·감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에, 평가가 먼저 이뤄집니다.

```jsx
let counter = 1;
alert(2 * ++counter); // 4
```

위 예시를 아래와 비교해 봅시다.

```jsx
let counter = 1;
alert(2 * counter++); // counter++는 '기존'값을 반환하기 때문에 2가 출력됩니다.
```

이렇게 코드를 작성하는 게 기술적으로 문제가 있는 것은 아니지만, 한 줄에서 여러 가지 일을 동시에 하고 있기 때문에 코드의 가독성이 떨어집니다.

코드를 읽을 때 눈을 ‘수직으로’ 빠르게 움직이다 보면 `counter++`와 같은 것을 놓치기 쉽습니다. 변수가 증가했다는 것을 놓칠 수 있죠.

'코드 한 줄엔, 특정 동작 하나’에 관련된 내용만 작성하는 게 좋습니다. 아래와 같이 말이죠.

```jsx
let counter = 1;
alert(2 * counter);
counter++;
```

## [쉼표 연산자](https://ko.javascript.info/operators#ref-1526)

쉼표 연산자(comma operator) `,`는 좀처럼 보기 힘들고, 특이한 연산자 중 하나입니다. 코드를 짧게 쓰려는 의도로 가끔 사용됩니다. 이런 코드를 만났을 때, 어떤 연산 결과가 도출되는지 알아야 하므로 쉼표 연산자에 대해 알아보도록 합시다.

쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해줍니다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의해야 합니다.

```jsx
let a = (1 + 2, 3 + 4);

alert(a); // 7 (3 + 4의 결과)
```

위 예시에서 첫 번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버려집니다. `3 + 4`만 평가되어 `a`에 할당되죠.

**쉼표의 우선순위는 매우 낮습니다.**

쉼표 연산자의 연산자 우선순위는 매우 낮습니다. 할당 연산자 `=` 보다 더 낮죠. 따라서 위 예시에선 괄호가 중요한 역할을 합니다.

괄호가 없으면 `a = 1 + 2, 3 + 4`에서 `+`가 먼저 수행되어 `a = 3, 7`이 됩니다. 할당 연산자 `=`는 쉼표 연산자보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지(`7`)는 무시되죠. `(a = 1 + 2), 3 + 4`를 연산한 것처럼 될 겁니다.

이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자는 어디서 사용되는 걸까요?

여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 이를 사용합니다.

아래와 같이 말이죠.

```jsx
// 한 줄에서 세 개의 연산이 수행됨
for (*a = 1, b = 3, c = a * b*; a < 10; a++) {
 ...
}
```

쉼표 연산자를 사용한 트릭은 여러 자바스크립트 프레임워크에서 볼 수 있습니다. 이 연산자의 사용 빈도가 높지 않지만, 언급하고 넘어가는 이유이죠. 쉼표 연산자는 코드 가독성에 도움이 되지 않습니다. 따라서 곰곰이 생각해 본 후, 진짜 필요한 경우에만 사용하시길 바랍니다.

<br>
<br>

# 2-10. if와 '?'를 사용한 조건 처리

if문을 쓸 때는 조건이 참일 경우 실행되는 구문이 단 한 줄이더라도 중괄호 {}를 사용해 코드를 블록으로 감싸는 것을 추천해 드립니다. 이렇게 하면 코드 가독성이 증가합니다.

## [불린형으로의 변환](https://ko.javascript.info/ifelse#ref-1532)

`if (…)` 문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환합니다.

[형 변환](https://ko.javascript.info/type-conversions) 챕터에서 배운 형 변환 규칙을 잠시 상기해 봅시다.

- 숫자 `0`, 빈 문자열`""`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 `false`가 됩니다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부릅니다.
- 이 외의 값은 불린형으로 변환시 `true`가 되므로 ‘truthy(참 같은)’ 값이라고 부릅니다.

이 규칙에 따르면 아래 예시의 코드 블록은 절대 실행되지 않습니다.

`if (0) { // 0은 falsy입니다. ... }`

아래 예시의 코드 블록은 항상 실행됩니다.

`if (1) { // 1은 truthy입니다. ... }`

아래와 같이 평가를 통해 확정된 불린값을 `if`문에 전달할 수도 있습니다.

```jsx
let cond = (year == 2015); // 동등 비교를 통해 true/false 여부를 결정합니다.

if (cond) {
  ...
}
```

## [조건부 연산자 ‘?’](https://ko.javascript.info/ifelse#ref-1535)

조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있습니다.

예시:

```jsx
let accessAllowed;
let age = prompt("나이를 입력해 주세요.", "");

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
alert(accessAllowed);
```

'물음표(question mark) 연산자’라고도 불리는 '조건부(conditional) 연산자’를 사용하면 위 예시를 더 짧고 간결하게 변형할 수 있습니다.

조건부 연산자는 물음표`?`로 표시합니다. 피연산자가 세 개이기 때문에 조건부 연산자를 '삼항(ternary) 연산자’라고 부르는 사람도 있습니다. 참고로, 자바스크립트에서 피연산자를 3개나 받는 연산자는 조건부 연산자가 유일합니다.

## [부적절한 ‘?’](https://ko.javascript.info/ifelse#ref-1537)

물음표`?`를 `if` 대용으로 쓰는 경우가 종종 있습니다.

```jsx
let company = prompt("자바스크립트는 어떤 회사가 만들었을까요?", "");

company == "Netscape" ? alert("정답입니다!") : alert("오답입니다!");
```

조건 `company == 'Netscape'`의 검사 결과에 따라 `?` 뒤에 이어지는 첫 번째 혹은 두 번째 표현식이 실행되어 얼럿 창이 뜹니다.

위 예시에선 평가 결과를 변수에 할당하지 않고, 결과에 따라 실행되는 표현식이 달라지도록 하였습니다.

그런데 **이런 식으로 물음표 연산자를 사용하는 것은 좋지 않습니다.**

개발자 입장에선 `if`문을 사용할 때 보다 코드 길이가 짧아진다는 점 때문에 물음표`?`를 `if` 대용으로 쓰는 게 매력적일 순 있습니다. 하지만 이렇게 코드를 작성하면 가독성이 떨어집니다.

아래는 `if`를 사용해 변형한 코드입니다. 어느 코드가 더 읽기 쉬운지 직접 비교해 보시기 바랍니다.

```jsx
let company = prompt("자바스크립트는 어떤 회사가 만들었을까요?", "");

if (company == "Netscape") {
  alert("정답입니다!");
} else {
  alert("오답입니다!");
}
```

코드를 읽을 때 우리의 눈은 수직으로 움직입니다. 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드 블록이 더 읽기 쉽죠.

물음표 연산자`?`는 조건에 따라 반환 값을 달리하려는 목적으로 만들어졌습니다. 이런 목적에 부합하는 곳에 물음표를 사용하시길 바랍니다. 여러 분기를 만들어 처리할 때는 `if`를 사용하세요.

<br>
<br>

# 2-12. nullish 병합 연산자 '??'

nullish 병합 연산자(nullish coalescing operator) `??`를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 찾을 수 있습니다.

`a ?? b`의 평가 결과는 다음과 같습니다.

- `a`가 `null`도 아니고 `undefined`도 아니면 `a`
- 그 외의 경우는 `b`

nullish 병합 연산자 `??`없이 `x = a ?? b`와 동일한 동작을 하는 코드를 작성하면 다음과 같습니다.

```jsx
x = a !== null && a !== undefined ? a : b;
```

`firstName`, `lastName`, `nickName`이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보겠습니다.

화면엔 세 변수 중 실제 값이 있는 변수의 값을 출력하는데, 세 변수 모두 값이 없다면 '익명의 사용자’가 출력되도록 해보죠.

이럴 때 nullish 병합 연산자 `??`를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있습니다.

```jsx
let firstName = null;
let lastName = null;
let nickName = "바이올렛";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
```

## ['??'와 '||'의 차이](https://ko.javascript.info/nullish-coalescing-operator#ref-1377)

nullish 병합 연산자는 OR 연산자 `||`와 상당히 유사해 보입니다. 실제로 위 예시에서 `??`를 `||`로 바꿔도 그 결과는 동일하기까지 하죠. 관련 내용은 [이전 챕터](https://ko.javascript.info/logical-operators#or-finds-the-first-truthy-value)에서 살펴본 바 있습니다.

그런데 두 연산자 사이에는 중요한 차이점이 있습니다.

- `||`는 첫 번째 *truthy* 값을 반환합니다.
- `??`는 첫 번째 *정의된(defined)* 값을 반환합니다.

`null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 합니다.

예시를 살펴봅시다.

```jsx
height = height ?? 100;
```

`height`에 값이 정의되지 않은경우 `height`엔 `100`이 할당됩니다.

이제 `??`와 `||`을 비교해봅시다.

```jsx
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

`height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리합니다. 따라서 `height || 100`의 평가 결과는 `100`입니다.

반면 `height ?? 100`의 평가 결과는 `height`가 정확하게 `null`이나 `undefined`일 경우에만 `100`이 됩니다. 예시에선 `height`에 `0`이라는 값을 할당했기 때문에 얼럿창엔 `0`이 출력됩니다.

이런 특징 때문에 높이처럼 `0`이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `||`보다 `??`가 적합합니다.

## [연산자 우선순위]

[??의 연산자 우선순위](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)는 `5`로 꽤 낮습니다.

따라서 `??`는 `=`와 `?` 보다는 먼저, 대부분의 연산자보다는 나중에 평가됩니다.

그렇기 때문에 복잡한 표현식 안에서 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋습니다.

```jsx
let height = null;
let width = null;

// 괄호를 추가!
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```

그렇지 않으면 `*`가 `??`보다 우선순위가 높기 때문에 `*`가 먼저 실행됩니다.

결국엔 아래 예시처럼 동작하겠죠.

```jsx
// 원치 않는 결과
let area = height ?? 100 * width ?? 50;
```

`??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있습니다.

**안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못합니다.**

아래 예시를 실행하면 문법 에러가 발생합니다.

```jsx
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```

이 제약에 대해선 아직 논쟁이 많긴 하지만 사람들이 `||`를 `??`로 바꾸기 시작하면서 만드는 실수를 방지하고자 명세서에 제약이 추가된 상황입니다.

제약을 피하려면 괄호를 사용해주세요.

```jsx
let x = (1 && 2) ?? 3; // 제대로 동작합니다.
alert(x); // 2
```

<br>
<br>

# 2-13. while과 for 반복문

- `while` – 각 반복이 시작하기 전에 조건을 확인합니다.
- `do..while` – 각 반복이 끝난 후에 조건을 확인합니다.
- `for (;;)` – 각 반복이 시작하기 전에 조건을 확인합니다. 추가 세팅을 할 수 있습니다.

‘무한’ 반복문은 보통 `while(true)`를 써서 만듭니다. 무한 반복문은 여타 반복문과 마찬가지로 `break` 지시자를 사용해 멈출 수 있습니다.

현재 실행 중인 반복에서 더는 무언가를 하지 않고 다음 반복으로 넘어가고 싶다면 `continue` 지시자를 사용할 수 있습니다.

반복문 앞에 레이블을 붙이고, `break/continue`에 이 레이블을 함께 사용할 수 있습니다. 레이블은 중첩 반복문을 빠져나와 바깥의 반복문으로 갈 수 있게 해주는 유일한 방법입니다.

### **[while 반복문의 출력값 예상하기](https://ko.javascript.info/while-for#ref-1329) 🔥**

while 반복문이 순차적으로 실행될 때마다 얼럿 창에 어떤 값이 출력될지 예상해보세요.

아래 두 예시는 같은 값을 출력할까요?

1.  전위형 증가 연산자를 사용한 경우(`++i`):

    ```jsx
    let i = 0;
    while (++i < 5) alert(i); // 1 ~ 4
    ```

2.  후위형 증가 연산자를 사용한 경우(`i++`):

        ```jsx
        let i = 0;
        while (i++ < 5) alert( i ); // 1 ~ 5
        ```

    이 문제는 비교 연산자와 후위/전위형 연산자를 함께 사용하는 경우 어떤 차이가 있는지 보여줍니다.

3.  전위형 증가 연산자를 사용한 경우엔 **1부터 4까지** 출력됩니다.

    ```jsx
    let i = 0;
    while (++i < 5) alert(i);
    ```

    `++i`는 `i`를 먼저 증가시키고 새로운 값을 반환하기 때문에 첫 번째 while 반복문에선 1과 5를 비교(`1 < 5`)하고, 얼럿 창엔 `1`이 출력됩니다.

    `1`에 이어서 `2, 3, 4…`이 출력됩니다. `i` 앞에 `++`가 붙어있기 때문에 `5`는 항상 증가 이후의 값과 비교됩니다.

    `i = 4` 이후에 `i`의 값이 `5`로 증가하면 `while(5 < 5)`안의 비교가 실패하기 때문에 반복문은 멈춥니다. 따라서 `5`는 출력되지 않습니다.

4.  후위형 증가 연산자를 사용한 경우엔 **1부터 5까지** 출력됩니다.

    ```jsx
    let i = 0;
    while (i++ < 5) alert(i);
    ```

    후위 증가 연산자를 적용하면 `i++`는 `i`를 증가시키긴 하지만 *기존* 값을 반환합니다. 따라서 첫 번째 while 반복문에선 0과 5를 비교(`0 < 5`)합니다. 이 점이 전위 증가 연산자와의 차이입니다.

    그런데 `alert`문은 조건문과 별개의 문이므로 얼럿창엔 `1`이 출력됩니다. `i`는 이미 증가한 이후이기 때문이죠.

    `1`이 출력된 이후에 `2, 3, 4…`가 이어서 출력됩니다.

    `i = 4`일 때 잠시 생각을 가다듬어 봅시다. 전위 증가 연산자(`++i`)를 사용하면 값이 먼저 증가하기 때문에 5와 `5`를 비교하게 되는데, 여기선 후위 증가 연산자(`i++`)를 사용하고 있으므로 `i`는 증가하지만 기존 값인 `4`가 비교에 사용됩니다. 따라서 `while(4 < 5)`가 되고, 해당 조건은 참이므로 하단 블록이 실행되어 `alert` 창이 뜨게 됩니다.

    다음 반복문은 `while(5 < 5)`이므로 마지막 출력되는 값은 `5`가 됩니다.

### **['for' 반복문의 출력값 예상하기](https://ko.javascript.info/while-for#ref-1330) 🔥**

for 반복문이 순차적으로 실행될 때마다 얼럿 창에 어떤 값이 출력될지 예상해보세요.

아래 두 예시는 같은 값을 출력할까요?

1. 후위형 증가 연산자를 사용한 경우(`i++`):

   ```jsx
   for (let i = 0; i < 5; i++) alert(i);
   ```

2. 전위형 증가 연산자를 사용한 경우(`++i`):

   ```jsx
   for (let i = 0; i < 5; ++i) alert(i);
   ```

   두 경우 모두 **`0`부터 `4`까지** 출력됩니다.

```jsx
for (let i = 0; i < 5; ++i) alert(i);

for (let i = 0; i < 5; i++) alert(i);
```

`for`문의 알고리즘을 떠올려보면 쉽게 추론할 수 있는 문제입니다.

1. 모든 작업이 시작되기 전 일단 `i = 0`입니다.
2. `i < 5` 조건을 만족하는지 확인합니다.
3. 위 조건이 `true`이면 반복문의 본문 `alert(i)`가 실행되고, 그 이후 `i++`가 실행됩니다.

`i++`는 위 알고리즘의 두 번째 단계(조건 확인)와 별개로 실행됩니다. 전혀 다른 구문이기 때문이죠.

증가 연산자가 반환하는 값은 (2) 에서 쓰이지 않기 때문에 `i++`와 `++i`에 차이가 없습니다.

### **[구성 요소 생략하기](https://ko.javascript.info/while-for#ref-1324) 🔥**

`for`문의 구성 요소를 생략하는 것도 가능합니다.

반복문이 시작될 때 아무것도 할 필요가 없으면 `begin`을 생략하는 것이 가능하죠.

예시를 살펴봅시다.

```jsx
let i = 0; // i를 선언하고 값도 할당하였습니다.

for (; i < 3; i++) {
  // 'begin'이 필요하지 않기 때문에 생략하였습니다.
  alert(i); // 0, 1, 2
}
```

`step` 역시 생략할 수 있습니다.

```jsx
let i = 0;

for (; i < 3; ) {
  alert(i++);
}
```

위와 같이 `for`문을 구성하면 `while (i < 3)`과 동일해집니다.

모든 구성 요소를 생략할 수도 있는데, 이렇게 되면 무한 반복문이 만들어집니다.

```jsx
for (;;) {
  // 끊임 없이 본문이 실행됩니다.
}
```

`for`문의 구성요소를 생략할 때 주의할 점은 두 개의 `;` 세미콜론을 꼭 넣어주어야 한다는 점입니다. 하나라도 없으면 문법 에러가 발생합니다.

### **[반복문 빠져나오기](https://ko.javascript.info/while-for#ref-1325) 🔥**

대개는 반복문의 조건이 falsy가 되면 반복문이 종료됩니다.

그런데 특별한 지시자인 `break`를 사용하면 언제든 원하는 때에 반복문을 빠져나올 수 있습니다.

아래 예시의 반복문은 사용자에게 일련의 숫자를 입력하도록 안내하고, 사용자가 아무런 값도 입력하지 않으면 반복문을 '종료’합니다.

```jsx
let sum = 0;

while (true) {

  let value = +prompt("숫자를 입력하세요.", '');

  *if (!value) break; // (*)*

  sum += value;

}
alert( '합계: ' + sum );
```

`(*)`로 표시한 줄에 있는 `break`는 사용자가 아무것도 입력하지 않거나 `Cancel`버튼을 눌렀을 때 활성화됩니다. 이때 반복문이 즉시 중단되고 제어 흐름이 반복문 아래 첫 번째 줄로 이동합니다. 여기선 `alert`가 그 첫 번째 줄이 되겠죠.

반복문의 시작 지점이나 끝 지점에서 조건을 확인하는 것이 아니라 본문 가운데 혹은 본문 여러 곳에서 조건을 확인해야 하는 경우, '무한 반복문 + `break`’ 조합을 사용하면 좋습니다.

### **[다음 반복으로 넘어가기](https://ko.javascript.info/while-for#continue) 🔥**

`continue` 지시자는 `break`의 '가벼운 버전’입니다. `continue`는 전체 반복문을 멈추지 않습니다. 대신에 현재 실행 중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시키도록 합니다(조건을 통과할 때).

`continue`는 현재 반복을 종료시키고 다음 반복으로 넘어가고 싶을 때 사용할 수 있습니다.

아래 반복문은 `continue`를 사용해 홀수만 출력합니다.

`for (let i = 0; i < 10; i++) {

// 조건이 참이라면 남아있는 본문은 실행되지 않습니다.
*if (i % 2 == 0) continue;*alert(i); // 1, 3, 5, 7, 9가 차례대로 출력됨
}`

`i`가 짝수이면 `continue`가 본문 실행을 중단시키고 다음 이터레이션이 실행되게 합니다(`i`가 하나 증가하고, 다음 반복이 실행됨). 따라서 `alert` 함수는 인수가 홀수일 때만 호출됩니다.

**`continue`는 중첩을 줄이는 데 도움을 줍니다.**

홀수를 출력해주는 예시는 아래처럼 생길 수도 있습니다.

```jsx
for (let i = 0; i < 10; i++) {
  if (i % 2) {
    alert(i);
  }
}
```

기술적인 관점에서 봤을 때, 이 예시는 위쪽에 있는 예시와 동일합니다. `continue`를 사용하는 대신 코드를 `if` 블록으로 감싼 점만 다릅니다.

그런데 이렇게 코드를 작성하면 부작용으로 중첩 레벨(대괄호 안의 `alert` 호출)이 하나 더 늘어납니다. `if` 안의 코드가 길어진다면 전체 가독성이 떨어질 수 있습니다.

**‘?’ 오른쪽엔 `break`나 `continue`가 올 수 없습니다.**

표현식이 아닌 문법 구조(syntax construct)는 삼항 연산자 `?`에 사용할 수 없다는 점을 항상 유의하시기 바랍니다. 특히 `break`나 `continue` 같은 지시자는 삼항 연산자에 사용하면 안 됩니다.

아래와 같은 조건문이 있다고 해봅시다.

```jsx
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

물음표를 사용해서 위 조건문을 아래와 같이 바꾸려는 시도를 할 수 있을겁니다.

```jsx
(i > 5) ? alert(i) : *continue*; // 여기에 continue를 사용하면 안 됩니다.
```

이런 코드는 문법 에러를 발생시킵니다.

이는 물음표 연산자 `?`를 `if`문 대용으로 쓰지 말아야 하는 이유 중 하나입니다.

### **[break/continue와 레이블](https://ko.javascript.info/while-for#ref-1326) 🔥**

여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우가 종종 생기곤 합니다.

`i`와 `j`를 반복하면서 프롬프트 창에 `(0,0)`부터 `(2,2)`까지를 구성하는 좌표 `(i, j)`를 입력하게 해주는 예시를 살펴봅시다.

```jsx
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`(${i},${j})의 값`, "");

    // 여기서 멈춰서 아래쪽의 `완료!`가 출력되게 하려면 어떻게 해야 할까요?
  }
}

alert("완료!");
```

사용자가 `Cancel` 버튼을 눌렀을 때 반복문을 중단시킬 방법이 필요합니다.

`input` 아래에 평범한 `break` 지시자를 사용하면 안쪽에 있는 반복문만 빠져나올 수 있습니다. 이것만으론 충분하지 않습니다(중첩 반복문을 포함한 반복문 두 개 모두를 빠져나와야 하기 때문이죠 – 옮긴이). 이럴 때 레이블을 사용할 수 있습니다.

*레이블(label)* 은 반복문 앞에 콜론과 함께 쓰이는 식별자입니다.

`labelName: for (...) { ... }`

반복문 안에서 `break <labelName>`문을 사용하면 레이블에 해당하는 반복문을 빠져나올 수 있습니다.

```jsx
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나옵니다.
    if (!input) *break outer*; // (*)

    // 입력받은 값을 가지고 무언가를 함
  }
}
alert('완료!');
```

위 예시에서 `break outer`는 `outer`라는 레이블이 붙은 반복문을 찾고, 해당 반복문을 빠져나오게 해줍니다.

따라서 제어 흐름이 `(*)`에서 `alert('완료!')`로 바로 바뀝니다.

레이블을 별도의 줄에 써주는 것도 가능합니다.

```jsx
outer:
for (let i = 0; i < 3; i++) { ... }
```

`continue` 지시자를 레이블과 함께 사용하는 것도 가능합니다. 두 가지를 같이 사용하면 레이블이 붙은 반복문의 다음 이터레이션이 실행됩니다.

**레이블은 마음대로 '점프’할 수 있게 해주지 않습니다.**

레이블을 사용한다고 해서 원하는 곳으로 마음대로 점프할 수 있는 것은 아닙니다.

아래 예시처럼 레이블을 사용하는 것은 불가능합니다.

```jsx
break label; // 아래 for 문으로 점프할 수 없습니다.

label: for (...)
```

`break`와 `continue`는 반복문 안에서만 사용할 수 있고, 레이블은 반드시 `break`이나 `continue` 지시자 위에 있어야 합니다.

<br>
<br>

# 2-14. switch문

복수의 `if` 조건문은 `switch`문으로 바꿀 수 있습니다.

`switch`문을 사용한 비교법은 특정 변수를 다양한 상황에서 비교할 수 있게 해줍니다. 코드 자체가 비교 상황을 잘 설명한다는 장점도 있습니다.

**문법**

`switch`문은 하나 이상의 `case`문으로 구성됩니다. 대개 `default`문도 있지만, 이는 필수는 아닙니다.

```jsx
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

- 변수 `x`의 값과 첫 번째 `case`문의 값 `'value1'`를 일치 비교한 후, 두 번째 `case`문의 값 `'value2'`와 비교합니다. 이런 과정은 계속 이어집니다.
- `case`문에서 변수 `x`의 값과 일치하는 값을 찾으면 해당 `case` 문의 아래의 코드가 실행됩니다. 이때, `break`문을 만나거나 `switch` 문이 끝나면 코드의 실행은 멈춥니다.
- 값과 일치하는 `case`문이 없다면, `default`문 아래의 코드가 실행됩니다(`default` 문이 있는 경우).

<br>
<br>

# 2-15. 함수

## 함수 이름짓기 ✨🔥

함수는 어떤 동작을 수행하기 위한 코드를 모아놓은 것입니다. 따라서 함수의 이름은 대개 동사입니다. 함수 이름은 가능한 한 간결하고 명확해야 합니다. 함수가 어떤 동작을 하는지 설명할 수 있어야 하죠. 코드를 읽는 사람은 함수 이름만 보고도 함수가 어떤 기능을 하는지 힌트를 얻을 수 있어야 합니다.

함수가 어떤 동작을 하는지 축약해서 설명해 주는 동사를 접두어로 붙여 함수 이름을 만드는 게 관습입니다. 다만, 팀 내에서 그 뜻이 반드시 합의된 접두어만 사용해야 합니다.

"show"로 시작하는 함수는 대개 무언가를 보여주는 함수입니다.

이 외에 아래와 같은 접두어를 사용할 수 있습니다.

```
"get…" – 값을 반환함
"calc…" – 무언가를 계산함
"create…" – 무언가를 생성함
"check…" – 무언가를 확인하고 불린값을 반환함
위 접두어를 사용하면 아래와 같은 함수를 만들 수 있습니다.

showMessage(..) // 메시지를 보여줌
getAge(..) // 나이를 나타내는 값을 얻고 그 값을 반환함
calcSum(..) // 합계를 계산하고 그 결과를 반환함
createForm(..) // form을 생성하고 만들어진 form을 반환함
checkPermission(..) // 승인 여부를 확인하고 true나 false를 반환함
접두어를 적절히 활용하면 함수 이름만 보고도 함수가 어떤 동작을 하고 어떤 값을 반환하는지 쉽게 알 수 있습니다.
```

함수는 동작 하나만 담당해야 합니다.
함수는 함수 이름에 언급되어 있는 동작을 정확히 수행해야 합니다. 그 이외의 동작은 수행해선 안 됩니다.

독립적인 두 개의 동작은 독립된 함수 두 개에서 나눠서 수행할 수 있게 해야 합니다. 한 장소에서 두 동작을 동시에 필요로 하는 경우라도 말이죠(이 경우는 제3의 함수를 만들어 그곳에서 두 함수를 호출합니다).

개발자들이 빈번히 하는 실수를 소개해 보겠습니다.

```
getAge 함수는 나이를 얻어오는 동작만 수행해야 합니다. alert 창에 나이를 출력해 주는 동작은 이 함수에 들어가지 않는 것이 좋습니다.

createForm 함수는 form을 만들고 이를 반환하는 동작만 해야 합니다. form을 문서에 추가하는 동작이 해당 함수에 들어가 있으면 좋지 않습니다.

checkPermission 함수는 승인 여부를 확인하고 그 결과를 반환하는 동작만 해야 합니다. 승인 여부를 보여주는 메시지를 띄우는 동작이 들어가 있으면 좋지 않습니다.
```

위 예시들은 접두어의 의미가 합의되었다고 가정하고 만들었습니다. 본인이나 본인이 속한 팀에서 접두어의 의미를 재합의하여 함수를 만들 수도 있긴 하지만, 아마도 위 예시에서 사용한 접두어 의미와 크게 차이가 나진 않을 겁니다. 어찌 되었든 접두어를 사용하여 함수 이름을 지을 땐, 해당 접두어에 어떤 의미가 있는지 잘 이해하고 있어야 합니다. 해당 접두어가 붙은 함수가 어떤 동작을 하는지, 어떤 동작은 하지 못하는지 알고 있어야 하죠. 접두어를 붙여 만든 모든 함수는 팀에서 만든 규칙을 반드시 따라야 합니다. 팀원들은 이 규칙을 충분히 이해하고 있어야 하며, 팀원들 사이에 이 규칙이 잘 공유되어야 합니다.

아주 짧은 이름
정말 빈번히 쓰이는 함수 중에 이름이 아주 짧은 함수가 있습니다.

jQuery 프레임워크에서 쓰이는 함수 $와 Lodash 라이브러리의 핵심 함수 `_` 말이죠.

이 함수들은 지금까지 소개한 함수 이름짓기에 관련된 규칙을 지키지 않고 있습니다. 예외에 속하죠. 함수 이름은 간결하고 함수가 어떤 일을 하는지 설명할 수 있게 지어야 합니다.

함수 == 주석
함수는 간결하고, 한 가지 기능만 수행할 수 있게 만들어야 합니다. 함수가 길어지면 함수를 잘게 쪼갤 때가 되었다는 신호로 받아들이셔야 합니다. 함수를 쪼개는 건 쉬운 작업은 아닙니다. 하지만 함수를 분리해 작성하면 많은 장점이 있기 때문에 함수가 길어질 경우엔 함수를 분리해 작성할 것을 권유합니다.

함수를 간결하게 만들면 테스트와 디버깅이 쉬워집니다. 그리고 함수 그 자체로 주석의 역할까지 합니다!

같은 동작을 하는 함수, showPrimes(n)를 두 개 만들어 비교해 봅시다. showPrimes(n)은 n까지의 소수(prime numbers)를 출력해줍니다.

첫 번째 showPrimes(n)에선 레이블을 사용해 반복문을 작성해보았습니다.

```jsx
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i); // 소수
  }
}
```

두 번째 showPrimes(n)는 소수인지 아닌지 여부를 검증하는 코드를 따로 분리해 isPrime(n)이라는 함수에 넣어서 작성했습니다.

```jsx
function showPrimes(n) {
  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i); // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

두 번째 showPrimes(n)가 더 이해하기 쉽지 않나요? isPrime 함수 이름을 보고 해당 함수가 소수 여부를 검증하는 동작을 한다는 걸 쉽게 알 수 있습니다. 이렇게 이름만 보고도 어떤 동작을 하는지 알 수 있는 코드를 자기 설명적(self-describing) 코드라고 부릅니다.

위와 같이 함수는 중복을 없애려는 용도 외에도 사용할 수 있습니다. 이렇게 함수를 활용하면 코드가 정돈되고 가독성이 높아집니다.

<br>
<br>

# 2-16. 함수 표현식

## 콜백 함수

함수를 값처럼 전달하는 예시, 함수 표현식에 관한 예시를 좀 더 살펴보겠습니다.

매개변수가 3개 있는 함수, `ask(question, yes, no)`를 작성해보겠습니다. 각 매개변수에 대한 설명은 아래와 같습니다.

`question` 질문<br>

`yes` "Yes"라고 답한 경우 실행되는 함수 <br>

`no` "No"라고 답한 경우 실행되는 함수<br>

함수는 반드시 `question(질문)`을 해야 하고, 사용자의 답변에 따라 `yes()` 나 `no()`를 호출합니다.

```jsx
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);`
```

이렇게 함수를 작성하는 방법은 실무에서 아주 유용하게 쓰입니다. 면대면으로 질문하는 것보다 위처럼 컨펌창을 띄워 질문을 던지고 답변을 받으면 간단하게 설문조사를 진행할 수 있습니다. 실제 상용 서비스에선 컨펌 창을 좀 더 멋지게 꾸미는 등의 작업이 동반되긴 하지만, 일단 여기선 그게 중요한 포인트는 아닙니다.

**함수 `ask`의 인수, `showOk`와 `showCancel`은 *콜백 함수* 또는 *콜백*이라고 불립니다.**

함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것이 콜백 함수의 개념입니다. 위 예시에선 사용자가 "yes"라고 대답한 경우 `showOk`가 콜백이 되고, "no"라고 대답한 경우 `showCancel`가 콜백이 됩니다.

아래와 같이 함수 표현식을 사용하면 코드 길이가 짧아집니다.

```jsx
function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "동의하십니까?",
  function () {
    alert("동의하셨습니다.");
  },
  function () {
    alert("취소 버튼을 누르셨습니다.");
  }
);
```

`ask(...)` 안에 함수가 선언된 게 보이시나요? 이렇게 이름 없이 선언한 함수는 *익명 함수(anonymous function)* 라고 부릅니다. 익명 함수는 (변수에 할당된 게 아니기 때문에) `ask` 바깥에선 접근할 수 없습니다. 위 예시는 의도를 가지고 이렇게 구현하였기 때문에 바깥에서 접근할 수 없어도 문제가 없습니다.

자바스크립트를 사용하다 보면 콜백을 활용한 코드를 아주 자연스레 만나게 됩니다. 이런 코드는 자바스크립트의 정신을 대변합니다.

**함수는 "동작"을 나타내는 값입니다.**

문자열이나 숫자 등의 일반적인 값들은 *데이터*를 나타냅니다.

함수는 하나의 *동작(action)*을 나타냅니다.

동작을 대변하는 값인 함수를 변수 간 전달하고, 동작이 필요할 때 이 값을 실행할 수 있습니다.

<br>
<br>

# 2-17. 화살표 함수 기본

함수 표현식보다 단순하고 간결한 문법으로 함수를 만들 수 있는 방법이 있습니다.

바로 화살표 함수(arrow function)를 사용하는 것입니다. 화살표 함수라는 이름은 문법의 생김새를 차용해 지어졌습니다.

```jsx
let func = (arg1, arg2, ...argN) => expression;
```

## 본문이 여러 줄인 화살표 함수

평가해야 할 표현식이나 구문이 여러 개인 함수가 있을 수도 있습니다. 이 경우 역시 화살표 함수 문법을 사용해 함수를 만들 수 있습니다. 다만, 이때는 중괄호 안에 평가해야 할 코드를 넣어주어야 합니다. 그리고 `return` 지시자를 사용해 명시적으로 결괏값을 반환해 주어야 합니다.

```jsx
let sum = (a, b) => {
  // 중괄호는 본문 여러 줄로 구성되어 있음을 알려줍니다.
  let result = a + b;
  return result; // 중괄호를 사용했다면, return 지시자로 결괏값을 반환해주어야 합니다.
};

alert(sum(1, 2)); // 3
```
